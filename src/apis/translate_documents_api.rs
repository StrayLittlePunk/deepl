/*
 * DeepL API Documentation
 *
 * The DeepL API provides programmatic access to DeepLâ€™s machine translation technology.
 *
 * The version of the OpenAPI document: 2.7.0
 *
 * Generated by: https://openapi-generator.tech
 */

use reqwest;

use super::{configuration, Error};
use crate::apis::ResponseContent;

/// struct for typed errors of method [`download_document`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DownloadDocumentError {
    Status400(),
    Status403(),
    Status404(crate::models::DocumentTranslationError),
    Status413(),
    Status429(),
    Status456(),
    Status500(),
    Status503(crate::models::DocumentTranslationError),
    Status504(),
    Status529(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_document_status`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDocumentStatusError {
    Status400(),
    Status403(),
    Status404(),
    Status413(),
    Status429(),
    Status456(),
    Status500(),
    Status504(),
    Status529(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`translate_document`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TranslateDocumentError {
    Status400(),
    Status403(),
    Status404(),
    Status413(),
    Status429(),
    Status456(),
    Status500(),
    Status504(),
    Status529(),
    UnknownValue(serde_json::Value),
}

/// Once the status of the document translation process is `done`, the result can be downloaded.   For privacy reasons the translated document is automatically removed from the server once it was downloaded and cannot be downloaded again.
pub async fn download_document(
    configuration: &configuration::Configuration,
    document_id: &str,
    get_document_status_request: crate::models::GetDocumentStatusRequest,
) -> Result<std::path::PathBuf, Error<DownloadDocumentError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/document/{document_id}/result",
        local_var_configuration.base_path,
        document_id = crate::apis::urlencode(document_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };
    local_var_req_builder = local_var_req_builder.json(&get_document_status_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DownloadDocumentError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve the current status of a document translation process. If the translation is still in progress, the estimated time remaining is also included in the response.
pub async fn get_document_status(
    configuration: &configuration::Configuration,
    document_id: &str,
    get_document_status_request: crate::models::GetDocumentStatusRequest,
) -> Result<crate::models::GetDocumentStatus200Response, Error<GetDocumentStatusError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/document/{document_id}",
        local_var_configuration.base_path,
        document_id = crate::apis::urlencode(document_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };
    local_var_req_builder = local_var_req_builder.json(&get_document_status_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetDocumentStatusError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This call uploads a document and queues it for translation. The call returns once the upload is complete, returning a document ID and key which can be used to [query the translation status](https://www.deepl.com/docs-api/documents/get-document-status) and to [download the translated document](https://www.deepl.com/docs-api/documents/download-document) once translation is complete.    Because the request includes a file upload, it must be an HTTP POST request with content type `multipart/form-data`.   Please be aware that the uploaded document is automatically removed from the server once the translated document has been downloaded. You have to upload the document again in order to restart the translation.   The maximum upload limit for documents is [available here](https://support.deepl.com/hc/articles/360020582359-Document-formats) and may vary based on API plan and document type.   You may specify the glossary to use for the document translation using the `glossary_id` parameter. **Important:** This requires the `source_lang` parameter to be set and the language pair of the glossary has to match the language pair of the request.
pub async fn translate_document(
    configuration: &configuration::Configuration,
    target_lang: crate::models::TargetLanguage,
    _file: std::path::PathBuf,
    source_lang: Option<crate::models::SourceLanguage>,
    filename: Option<&str>,
    formality: Option<crate::models::Formality>,
    glossary_id: Option<&str>,
) -> Result<crate::models::TranslateDocument200Response, Error<TranslateDocumentError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/document", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };
    let mut local_var_form = reqwest::multipart::Form::new();
    if let Some(local_var_param_value) = source_lang {
        local_var_form = local_var_form.text("source_lang", local_var_param_value.to_string());
    }
    local_var_form = local_var_form.text("target_lang", target_lang.to_string());
    // TODO: support file upload for 'file' parameter
    if let Some(local_var_param_value) = filename {
        local_var_form = local_var_form.text("filename", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = formality {
        local_var_form = local_var_form.text("formality", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = glossary_id {
        local_var_form = local_var_form.text("glossary_id", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.multipart(local_var_form);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TranslateDocumentError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}
